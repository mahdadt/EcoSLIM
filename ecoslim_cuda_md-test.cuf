module particles_para_cuda_m
  !real*8,texture,pointer::dz_T(:),EvapTrans_T(:,:,:)
  !real*8,texture,pointer::Vx_T(:,:,:),Vy_T(:,:,:),Vz_T(:,:,:)
  !real*8,texture,pointer::Saturation_T(:,:,:),Porosity_T(:,:,:)
contains
 attributes(global) subroutine particles_independent(&
 P,C,dz_T,EvapTrans_T,Vx_T,Vy_T,Vz_T,Saturation_T,Porosity_T,&
 out_age,out_mass,out_comp,et_age,et_mass,et_comp,&
 out_np,et_np,kk,np_ps,nx,ny,nz,pfnt,&
 pfdt,moldiff,dx,dy,denh2o,dtfrac,xmin,ymin,zmin,&
 xmax,ymax,zmax,rank)
 
  implicit none
  
  integer,parameter::block_size = 256
  real*8,intent(inout)::P(:,:),C(:,:,:,:)
  real*8,intent(inout)::dz_T(:),EvapTrans_T(:,:,:),Vx_T(:,:,:),Vy_T(:,:,:)
  real*8,intent(inout)::Vz_T(:,:,:),Saturation_T(:,:,:),Porosity_T(:,:,:)
  real*8,shared::P_s(block_size,10)
  
  integer,value::kk,np_ps,nx,ny,nz,pfnt,rank
  real*8,value::pfdt,moldiff,dx,dy,denh2o,dtfrac
  real*8,value::xmin,ymin,zmin,xmax,ymax,zmax
  
  integer::ii,ii_g,k,itime_loc,index1,Ploc(3),ir
  real*8::Clocx,Clocy,Clocz,Vpx,Z,Vpy,Vpz,&
  particledt,delta_time,local_flux,et_flux,water_vol,advdt(3),&
  z1,z2,z3,Zr,temp,lock

  !global
  real*8,intent(inout)::out_age(:),out_mass(:),out_comp(:),&
  et_age(:),et_mass(:),et_comp(:)
  integer,intent(inout)::out_np(:),et_np(:)

  !shared in the block
  real*8,shared::out_age_s(block_size),out_mass_s(block_size),&
  out_comp1_s(block_size),out_comp2_s(block_size),out_comp3_s(block_size)
  real*8,shared::et_age_s(block_size),et_mass_s(block_size),&
  et_comp1_s(block_size),et_comp2_s(block_size),et_comp3_s(block_size)
  integer,shared::out_np_s(block_size),et_np_s(block_size)

  !private for each thread
  real*8::out_age_p,out_mass_p,out_comp1_p,out_comp2_p,out_comp3_p
  real*8::et_age_p,et_mass_p,et_comp1_p,et_comp2_p,et_comp3_p
  integer::out_np_p,et_np_p

  !for random number
  real*8 r(97),rm1,rm2
  integer j
  integer iff,ix1,ix2,ix3
  iff = 0 

  lock = 1.  
!=============================================================================   
  out_age_p   = 0.d0
  out_mass_p  = 0.d0
  out_comp1_p = 0.d0
  out_comp2_p = 0.d0
  out_comp3_p = 0.d0
  et_age_p    = 0.d0
  et_mass_p   = 0.d0
  et_comp1_p  = 0.d0
  et_comp2_p  = 0.d0
  et_comp3_p  = 0.d0
  out_np_p    = 0
  et_np_p     = 0
!=============================================================================   
  index1 = (blockIdx%x - 1) * blockDim%x + threadIdx%x
  ii = threadIdx%x

  do ii_g = index1, np_ps, blockDim%x * gridDim%x
  
    P_s(ii,:) = P(ii_g,:)  
    !call syncthreads()
!=============================================================================     
    ir = -(932117 + np_ps*rank + ii_g + 100*kk)
    
    delta_time = 0.d0
    
    if(P_s(ii,8) == 1.) then

        delta_time = P_s(ii,4) + pfdt

        do while (P_s(ii,4) < delta_time)
		
            ! Find the "adjacent" cell corresponding to the particle's location
            Ploc(1) = floor(P_s(ii,1) / dx)
            Ploc(2) = floor(P_s(ii,2) / dy)

            Z = 0.
            do k = 1, nz
                Z = Z + dz_T(k)
                if (Z >= P_s(ii,3)) then
                    Ploc(3) = k - 1
                    exit
                end if
            end do	

            ! check to make sure particles are in central part of the domain and if not
            ! apply some boundary condition to them
            ! check if particles are in domain, need to expand this to include better treatment of BC's
            if ((P_s(ii,1) < Xmin).or.(P_s(ii,2) < Ymin).or.(P_s(ii,3) < Zmin).or.  &
            (P_s(ii,1) >= Xmax).or.(P_s(ii,2) >= Ymax).or.(P_s(ii,3) >= (Zmax-dz_T(nz)))) then
            
            if ((P_s(ii,3) >= Zmax-(dz_T(nz)*0.5)).and.   &
            (Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.).and.  &
             (Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) > 0.)) then
             
            !itime_loc = kk
            !if (itime_loc <= 0) itime_loc = 1
            !if (itime_loc >= pfnt) itime_loc = pfnt

            Out_age_p = Out_age_p + P_s(ii,4)*P_s(ii,6)

            Out_mass_p = Out_mass_p + P_s(ii,6)

            if (P_s(ii,7) == 1.) then
            Out_comp1_p = Out_comp1_p + P_s(ii,6)
            end if

            if (P_s(ii,7) == 2.) then
            Out_comp2_p = Out_comp2_p + P_s(ii,6)
            end if
            
            if (P_s(ii,7) == 3.) then
            Out_comp3_p = Out_comp3_p + P_s(ii,6)
            end if
            
            Out_np_p = Out_np_p + 1

            !flag particle as inactive
            P_s(ii,8) = 0.
            !flag as exiting via Outflow
            P_s(ii,10) = 1.
            goto 999
            
            end if
            ! otherwise we just leave it in the domain to reflect
            end if	
			
            ! Find each particle's factional cell location
            Clocx = (P_s(ii,1) - float(Ploc(1))*dx)  / dx
            Clocy = (P_s(ii,2) - float(Ploc(2))*dy)  / dy

            Z = 0.
            do k = 1, Ploc(3)
                Z = Z + dz_T(k)
            end do
            Clocz = (P_s(ii,3) - Z) / dz_T(Ploc(3) + 1)

            ! Calculate local particle velocity using linear interpolation,
            ! converting darcy flux to average linear velocity

            Vpx = ((1.-Clocx)*Vx_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  + Vx_T(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1)*Clocx)   &
                  /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                  *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpy = ((1.-Clocy)*Vy_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    + Vy_T(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1)*Clocy) &
                    /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                    *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            Vpz = ((1.-Clocz)*Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      + Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2)*Clocz)  &
                        /(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) &
                      *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))

            ! calculate particle dt
            ! check each direction independently
            advdt = pfdt
            if (Vpx /= 0.) advdt(1) = abs(dtfrac*(dx/Vpx))
            if (Vpy /= 0.) advdt(2) = abs(dtfrac*(dy/Vpy))
            if (Vpz /= 0.) advdt(3) = dtfrac*(dz_T(Ploc(3)+1)/abs(Vpz))

            particledt = min(advdt(1), advdt(2), advdt(3), &
                      pfdt*dtfrac, delta_time-P_s(ii,4))

            ! calculate Flux in cell and compare it with the ET flux out of the cell
            if (EvapTrans_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) < 0.)then
            
            ! calculate divergence of Darcy flux in the cell
            !  in X, Y, Z [L^3 / T]
            !local_flux = (Vx_T(Ploc(1)+2,Ploc(2)+1,Ploc(3)+1) - Vx_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) +  &
            !             (Vy_T(Ploc(1)+1,Ploc(2)+2,Ploc(3)+1) - Vy_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)) +  &
            !             (Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+2) - Vz_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
            !
            ! calculate ET flux volumetrically and compare to
            et_flux = abs(EvapTrans_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))*dx*dy*dz_T(Ploc(3)+1)
            
            ! compare total water removed from cell by ET with total water available in cell to arrive at a particle
            ! probability of being captured by roots
            ! water volume in cell
            water_vol = dx*dy*dz_T(Ploc(3)+1)*(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)  &
            *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))
            !!  add that amout of mass to ET BT; check if particle is out of mass
            !itime_loc = kk
            !! extra checking for array bounds to provide future flexibilty
            !! if DT for output != PFDT
            !if (itime_loc <= 0) itime_loc = 1
            !if (itime_loc >= pfnt) itime_loc = pfnt
            Zr = ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)
            if (Zr < ((et_flux*particledt)/water_vol)) then   ! check if particle is 'captured' by the roots			
            !  this section made atomic since it could inovlve a data race
            !  that is, each thread can only update the ET arrays one at a time

            ET_age_p = ET_age_p + P_s(ii,4)*P_s(ii,6)  ! mass weighted age

            ET_mass_p = ET_mass_p + P_s(ii,6)  ! particle mass added to ET

            if (P_s(ii,7) == 1.) then
            ET_comp1_p = ET_comp1_p + P_s(ii,6)
            end if
            
            if (P_s(ii,7) == 2.) then
            ET_comp2_p = ET_comp2_p + P_s(ii,6)
            end if
            
            if (P_s(ii,7) == 3.) then
            ET_comp3_p = ET_comp3_p + P_s(ii,6)
            end if
            
            ET_np_p = ET_np_p + 1   ! track number of particles
            
            !outputting spatially distributed ET information
            temp = atomicAdd(C(6,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),lock)
            
            temp = atomicAdd(C(7,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,6)) ! particle mass added to ET
            
            temp = atomicAdd(C(8,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,4)*P_s(ii,6))  ! mass weighted age
            
            temp = atomicAdd(C(9,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,7)*P_s(ii,6))  ! mass weighted contribution

            !now remove particle from domain
            P_s(ii,8) = 0.
            !flag as exiting via ET
            P_s(ii,10) = 2.
            
            goto 999
            end if			
            end if
            
            !debuga(ii,1) = ploc(1)
            !debuga(ii,2) = ploc(2)
            !debuga(ii,3) = ploc(3)
            
            ! Advect particle to new location using Euler advection until next time
            P_s(ii,1) = P_s(ii,1) + particledt * Vpx
            P_s(ii,2) = P_s(ii,2) + particledt * Vpy
            P_s(ii,3) = P_s(ii,3) + particledt * Vpz
            P_s(ii,4) = P_s(ii,4) + particledt

            ! Molecular Diffusion
            if (moldiff > 0.) then
            z1 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)
            z2 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)
            z3 = 2.*SQRT(3.)*(ran1_gpu(ir,iff,ix1,ix2,ix3,j,r,rm1,rm2)-0.5)
            
            P_s(ii,1) = P_s(ii,1) + z1 * SQRT(moldiff*2.*particledt)
            P_s(ii,2) = P_s(ii,2) + z2 * SQRT(moldiff*2.*particledt)
            P_s(ii,3) = P_s(ii,3) + z3 * SQRT(moldiff*2.*particledt)
            end if

!!  placeholder for other interactions; potentially added later
!!
            ! place to track saturated / groundwater time if needed
            if(Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1) == 1.) P_s(ii,5) = P_s(ii,5) + particledt
            ! simple reflection boundary
            if (P_s(ii,3) >=Zmax) P_s(ii,3) = Zmax- (P_s(ii,3) - Zmax)
            if (P_s(ii,1) >=Xmax) P_s(ii,1) = Xmax- (P_s(ii,1) - Xmax)
            if (P_s(ii,2) >=Ymax) P_s(ii,2) = Ymax- (P_s(ii,2) - Ymax)
            if (P_s(ii,2) <=Ymin) P_s(ii,2) = Ymin+ (Ymin - P_s(ii,2))
            if (P_s(ii,3) <=Zmin) P_s(ii,3) = Zmin+ (Zmin - P_s(ii,3))
            if (P_s(ii,1) <=Xmin) P_s(ii,1) = Xmin+ (Xmin - P_s(ii,1))

            ! write all active particles at concentration in ASCII VisIT 3D file format continuously
            ! as noted above, this option is very slow compared to VTK binary output
            !if (ipwrite < 0) then
            !  if (P_s(ii,8) == 1.) write(214,61) P_s(ii,1), P_s(ii,2), P_s(ii,3), P_s(ii,4)
            !flush(214)
            !end if !! ipwrite


        end do  ! end of do-while loop for particle time to next time  			
        999 continue   ! where we go if the particle is out of bounds	

            ! concentration routine
            ! Find the "adjacent" "cell corresponding to the particle's location
            Ploc(1) = floor(P_s(ii,1) / dx)
            Ploc(2) = floor(P_s(ii,2) / dy)
            Z = 0.
            do k = 1, nz
                Z = Z + dz_T(k)
                if (Z >= P_s(ii,3)) then
                        Ploc(3) = k - 1
                        exit
                end if
            end do
            
            temp = atomicAdd(C(1,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,6) /  &
            (dx*dy*dz_T(Ploc(3)+1)*(Porosity_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1)   &
             *Saturation_T(Ploc(1)+1,Ploc(2)+1,Ploc(3)+1))))
            
            temp = atomicAdd(C(2,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,4)*P_s(ii,6))
                                                                                    
            temp = atomicAdd(C(4,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,7)*P_s(ii,6))
                                                                                    
            temp = atomicAdd(C(3,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,6))
                                                                                    
            temp = atomicAdd(C(5,Ploc(1)+1,Ploc(2)+1,Ploc(3)+1),P_s(ii,8)*P_s(ii,9)*P_s(ii,6)) 
		
    end if
    
    P(ii_g,:) = P_s(ii,:)
    !call syncthreads()
    
  end do    
!=============================================================================  
    out_age_s(ii)    = out_age_p
    out_mass_s(ii)   = out_mass_p 
    out_comp1_s(ii)  = out_comp1_p
    out_comp2_s(ii)  = out_comp2_p
    out_comp3_s(ii)  = out_comp3_p
    out_np_s(ii)     = out_np_p
    et_age_s(ii)     = et_age_p
    et_mass_s(ii)    = et_mass_p
    et_comp1_s(ii)   = et_comp1_p
    et_comp2_s(ii)   = et_comp2_p
    et_comp3_s(ii)   = et_comp3_p
    et_np_s(ii)      = et_np_p
    
    call syncthreads()
!============================================================================= 
  k = blockDim%x/2
  do while ( k >= 1) 
      if (ii <= k) then
        out_age_s(ii)   = out_age_s(ii)   + out_age_s(ii+k)
        out_mass_s(ii)  = out_mass_s(ii)  + out_mass_s(ii+k)
        out_comp1_s(ii) = out_comp1_s(ii) + out_comp1_s(ii+k)
        out_comp2_s(ii) = out_comp2_s(ii) + out_comp2_s(ii+k)
        out_comp3_s(ii) = out_comp3_s(ii) + out_comp3_s(ii+k)
        out_np_s(ii)    = out_np_s(ii)    + out_np_s(ii+k)
        et_age_s(ii)    = et_age_s(ii)    + et_age_s(ii+k)
        et_mass_s(ii)   = et_mass_s(ii)   + et_mass_s(ii+k)
        et_comp1_s(ii)  = et_comp1_s(ii)  + et_comp1_s(ii+k)
        et_comp2_s(ii)  = et_comp2_s(ii)  + et_comp2_s(ii+k)
        et_comp3_s(ii)  = et_comp3_s(ii)  + et_comp3_s(ii+k)
        et_np_s(ii)     = et_np_s(ii)     + et_np_s(ii+k)       
      end if
      k = k / 2
      call syncthreads()
  end do
 
  if(ii == 1) then
    temp     = atomicAdd(out_age(1),    out_age_s(1)  ) 
    temp     = atomicAdd(out_mass(1),   out_mass_s(1) )
    temp     = atomicAdd(out_comp(1),out_comp1_s(1))
    temp     = atomicAdd(out_comp(2),out_comp2_s(1))
    temp     = atomicAdd(out_comp(3),out_comp3_s(1))
    temp     = atomicAdd(out_np(1),     out_np_s(1)   )
    temp     = atomicAdd(et_age(1),     et_age_s(1)   )
    temp     = atomicAdd(et_mass(1),    et_mass_s(1)  )
    temp     = atomicAdd(et_comp(1), et_comp1_s(1) )
    temp     = atomicAdd(et_comp(2), et_comp2_s(1) )
    temp     = atomicAdd(et_comp(3), et_comp3_s(1) )
    temp     = atomicAdd(et_np(1),      et_np_s(1)    ) 
  end if
  
  call syncthreads() 
  
 end subroutine particles_independent
!============================================================================= 
      attributes(device) function ran1_gpu(idum,iff,ix1,ix2,ix3,j,r,rm1,rm2)
        implicit none  !note after use statement
        real*8 ran1_gpu
        integer, intent(inout), optional :: idum
        real*8 r(97),rm1,rm2
        integer, parameter :: m1=259200,ia1=7141,ic1=54773
        integer, parameter :: m2=134456,ia2=8121,ic2=28411
        integer, parameter :: m3=243000,ia3=4561,ic3=51349
        integer j
        integer iff,ix1,ix2,ix3
        !data iff /0/
        !iff = 0
!        save iff,ix1,ix2,ix3,j,r,rm1,rm2
        if(present(idum))then
          if (idum<0.or.iff.eq.0)then
            rm1=1.0/m1
            rm2=1.0/m2
            iff=1
            ix1=mod(ic1-idum,m1)
            ix1=mod(ia1*ix1+ic1,m1)
            ix2=mod(ix1,m2)
            ix1=mod(ia1*ix1+ic1,m1)
            ix3=mod(ix1,m3)
            do j=1,97
                ix1=mod(ia1*ix1+ic1,m1)
                ix2=mod(ia2*ix2+ic2,m2)
                r(j)=(real(ix1)+real(ix2)*rm2)*rm1
            enddo
            idum=1
          endif
        endif
        ix1=mod(ia1*ix1+ic1,m1)
        ix2=mod(ia2*ix2+ic2,m2)
        ix3=mod(ia3*ix3+ic3,m3)
        j=1+(97*ix3)/m3
        !if(j>97.or.j<1)then
        !    write(*,*)' error in ran1_gpu j=',j
        !    stop
        !endif
        ran1_gpu=r(j)
        r(j)=(real(ix1)+real(ix2)*rm2)*rm1
        return
     end function ran1_gpu
end module particles_para_cuda_m